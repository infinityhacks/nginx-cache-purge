#!/usr/bin/php -d disable_functions = show_source
<?php
use NginxCP\Cache;
use NginxCP\Inotify;
use NginxCP\Queue;
use Predis\Client as PredisClient;

define('RESCAN_TIME', 60*15);

require __DIR__.'/vendor/autoload.php';

passthru(__DIR__.'/fix_inotify_wait');

$CACHE_PATH = "/mnt/cache";

$lock_file = "/tmp/.nginx-cache-purge-".md5($CACHE_PATH).".lock";
if (file_exists($lock_file))
{
    $pid = file_get_contents($lock_file);
    exec("ps $pid", $output);
    if (count($output) == 2)
    {
        echo implode("\n", $output);
        echo "cache purge already running for $CACHE_PATH pid from\n$lock_file\n";
        exit(1);
    }
}
file_put_contents($lock_file, getmypid());

$predis = new PredisClient();
$cache = new Cache($CACHE_PATH);
$inotify = new Inotify($CACHE_PATH);
$queue = new Queue($predis);

// get the keys already in the cache before we started inotify
echo date('Y-m-d H:i:s')." - Scanning cache\n";
$cache->scan($CACHE_PATH);
echo date('Y-m-d H:i:s')." - Found ".count($cache->keys)." keys in the cache\n";

$last = time();
while(true)
{
	// update keys from inotify
	$updates = $inotify->getUpdates();
	$cache->update($updates);

	// get any purge jobs
	$item = $queue->getJob();
	if (!empty($item))
	{
		echo date('Y-m-d H:i:s')." - Purging $item\n";
		$cache->purge($item);
        $queue->completeJob($item);
		echo date('Y-m-d H:i:s')." - We now have ".count($cache->keys)." keys\n";
	}
	else
	{
        if (time()-$last > RESCAN_TIME)
        {
            echo date('Y-m-d H:i:s')." - Rescanning $CACHE_PATH\n";
            $cache->scan($CACHE_PATH);
            $last = time();
        }
//		echo date('Y-m-d H:i:s')." - Sleeping\n";
		sleep(1);
	}
}

unlink($lock_file);
?>
