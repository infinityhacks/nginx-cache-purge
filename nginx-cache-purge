#!/usr/bin/php -d disable_functions = show_source
<?php
use NginxCP\Cache;
use NginxCP\Inotify;
use NginxCP\Queue;
use Predis\Client as PredisClient;

$RESCAN_TIME = 60*15;

require __DIR__.'/vendor/autoload.php';

passthru(__DIR__.'/fix_inotify_wait');

$CACHE_PATH = "/mnt/cache";

$lock_file = "/tmp/.nginx-cache-purge-".md5($CACHE_PATH).".lock";
if (file_exists($lock_file))
{
    $pid = file_get_contents($lock_file);
    exec("ps $pid", $output);
    if (count($output) == 2)
    {
        echo implode("\n", $output);
        echo "cache purge already running for $CACHE_PATH pid from\n$lock_file\n";
        exit(1);
    }
}
file_put_contents($lock_file, getmypid());

$predis = new PredisClient();
$cache = new Cache($CACHE_PATH);
$inotify = new Inotify($CACHE_PATH);
$queue = new Queue($predis);

// I suspect it's possible to get killed half-way through processing a job,
// where we popped it from the queue but haven't cleared out the
// in_purge_list. nginx will stop accepting any new jobs for that purge, and
// we end up in a deadlock.
$predis->del("in_purge_list");

// get the keys already in the cache before we started inotify
echo date('Y-m-d H:i:s')." - Scanning cache\n";
$cache->scan($CACHE_PATH);
echo date('Y-m-d H:i:s')." - Found ".count($cache->keys, COUNT_RECURSIVE)." keys in the cache\n";

$last = time();
while(true)
{
	// update keys from inotify
    try {
        $updates = $inotify->getUpdates();
    }
    catch(\Exception $e)
    {
        // this means inotify has failed so let's exit so that supervisor will
        // restart us
        // we also need to kill our children; inotifywait runs forever in a
        // loop and if not interrupted we would be stuck here waiting for it
        // to exit on its own
        $inotify->killInotify();
        exit(1);
    }
	$cache->update($updates);

	// get any purge jobs
	$item = $queue->getJob();
	if (!empty($item))
	{
		echo date('Y-m-d H:i:s')." - Purging $item\n";
		$cache->purge($item);
        $queue->completeJob($item);
        $count = count($cache->keys, COUNT_RECURSIVE);
        if ($count > 50000)
        {
            $RESCAN_TIME = 60*60;
        }
		echo date('Y-m-d H:i:s')." - We now have $count keys\n";
	}
	else
	{
        if (time()-$last > $RESCAN_TIME)
        {
            echo date('Y-m-d H:i:s')." - Rescanning $CACHE_PATH\n";
            $cache->scan($CACHE_PATH);
            $last = time();
        }
//		echo date('Y-m-d H:i:s')." - Sleeping\n";
		sleep(1);
	}
}

unlink($lock_file);
?>
